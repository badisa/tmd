# Copyright 2019-2025, Relay Therapeutics
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Intended to test the custom_ops.HilbertSort. Note that this does not compare against the
the tests/common.py::hilbert_sort function which produces a different permutation. This simply verifies that
sorting will produce more compact blocks.
"""

import numpy as np
import pytest
from numpy.typing import NDArray

from tmd.lib import custom_ops
from tmd.potentials.jax_utils import delta_r
from tmd.testsystems.dhfr import setup_dhfr

pytestmark = [pytest.mark.memcheck]


def get_max_block_distances(coords: NDArray, box: NDArray, block_size: int) -> NDArray:
    """Compute the max distance between all particles within each block"""
    # Act on a copy to avoid modifying original coordinates
    coords = coords.copy()
    N = coords.shape[0]
    num_blocks = (N + block_size - 1) // block_size
    block_distances = []
    for bidx in range(num_blocks):
        start_idx = bidx * block_size
        end_idx = min((bidx + 1) * block_size, N)
        block = coords[start_idx:end_idx]
        block_distances.append(np.max(np.linalg.norm(delta_r(block[:, None], block[None, :], box=box), axis=-1)))
    return np.array(block_distances)


@pytest.mark.parametrize("block_size", [8, 16, 32])
@pytest.mark.parametrize("precision", [np.float32, np.float64])
def test_hilbert_sort_dhfr(block_size, precision):
    _, _, coords, box = setup_dhfr()
    distances = get_max_block_distances(coords, box, block_size)
    unsorted_mean_dist = np.mean(distances)

    if precision == np.float32:
        sort_class = custom_ops.HilbertSort_f64
    else:
        sort_class = custom_ops.HilbertSort_f32

    sorter = sort_class(coords.shape[0])
    perm = sorter.sort(coords, box)
    sorted_coords = coords[perm]
    sorted_dists = get_max_block_distances(sorted_coords, box, block_size)
    sorted_mean_dist = np.mean(sorted_dists)
    # On average the max distance within blocks generated by hilbert curve sorting should be smaller by some factor
    # of the unsorted distances
    assert sorted_mean_dist < (unsorted_mean_dist * 0.6)
